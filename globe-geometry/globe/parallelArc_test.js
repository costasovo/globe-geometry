// Generated by github.com/steida/coffee2closure 0.1.12
goog.require('globeGeometry.LatLng');
suite('globeGeometry.globe.ParallelArc', function() {
  var LatLng, ParallelArc;
  ParallelArc = globeGeometry.globe.ParallelArc;
  LatLng = globeGeometry.LatLng;
  suite('crossesDateMeridian', function() {
    test('should work for non crossing', function() {
      var arc;
      arc = new ParallelArc(10, 20);
      assert.isFalse(arc.crossesDateMeridian());
      arc = new ParallelArc(-10, 20);
      assert.isFalse(arc.crossesDateMeridian());
      arc = new ParallelArc(-170, 170);
      return assert.isFalse(arc.crossesDateMeridian());
    });
    return test('should work for crossing', function() {
      var arc;
      arc = new ParallelArc(170, -170);
      assert.isTrue(arc.crossesDateMeridian());
      arc = new ParallelArc(0, -1);
      assert.isTrue(arc.crossesDateMeridian());
      arc = new ParallelArc(-170, -175);
      assert.isTrue(arc.crossesDateMeridian());
      arc = new ParallelArc(-107.578125, -146.953125);
      return assert.isTrue(arc.crossesDateMeridian());
    });
  });
  suite('crossesZeroMeridian', function() {
    test('should work for non crossing', function() {
      var arc;
      arc = new ParallelArc(10, 20);
      assert.isFalse(arc.crossesZeroMeridian());
      arc = new ParallelArc(-20, -10);
      assert.isFalse(arc.crossesZeroMeridian());
      arc = new ParallelArc(170, 175);
      return assert.isFalse(arc.crossesZeroMeridian());
    });
    return test('should work for crossing', function() {
      var arc, input, inputs, _i, _len, _results;
      inputs = [[-10, 20], [170, 100], [-107.578125, -146.953125], [149.0625, 98.4375]];
      _results = [];
      for (_i = 0, _len = inputs.length; _i < _len; _i++) {
        input = inputs[_i];
        arc = new ParallelArc(input[0], input[1]);
        _results.push(assert.isTrue(arc.crossesZeroMeridian()));
      }
      return _results;
    });
  });
  suite('getCenter', function() {
    test('should work for non crossing date meridian', function() {
      var arc;
      arc = new ParallelArc(-22.8515625, 22.5);
      assert.equal(arc.getCenter(), -0.17578125);
      arc = new ParallelArc(46.7578125, 105.46875);
      assert.equal(arc.getCenter(), 76.11328125);
      arc = new ParallelArc(-43.59375, 170.5078125);
      assert.equal(arc.getCenter(), 63.45703125);
      arc = new ParallelArc(108.28125, 176.484375);
      return assert.equal(arc.getCenter(), 142.3828125);
    });
    return test('should work for crossing date meridian', function() {
      var arc;
      arc = new ParallelArc(137.4609375, -147.65625);
      assert.equal(arc.getCenter(), 174.90234375);
      arc = new ParallelArc(-148.359375, 158.90625);
      assert.equal(arc.getCenter(), 5.2734375);
      arc = new ParallelArc(-118.828125, -149.0625);
      assert.equal(arc.getCenter(), 46.0546875);
      arc = new ParallelArc(172.265625, 26.71875);
      assert.equal(arc.getCenter(), -80.5078125);
      arc = new ParallelArc(171.5625, 144.84375);
      assert.equal(arc.getCenter(), -21.796875);
      arc = new ParallelArc(156.09375, 92.109375);
      assert.equal(arc.getCenter(), -55.8984375);
      arc = new ParallelArc(151.875, -47.109375);
      return assert.equal(arc.getCenter(), -127.6171875);
    });
  });
  suite('contains', function() {
    test('should work for points inside', function() {
      var arc, input, inputs, _i, _len, _results;
      inputs = [[-49.921875, 64.3359375, 7.20703125], [-149.0625, 152.578125, 1.7578125], [24.609375, 111.796875, 68.203125], [-155.390625, -93.515625, -124.453125], [140.625, -88.59375, -153.984375], [-146.953125, 87.890625, -29.53125], [-107.578125, -146.953125, 52.734375], [149.0625, 98.4375, -56.25], [140.625, -88.59375, 153.984375]];
      _results = [];
      for (_i = 0, _len = inputs.length; _i < _len; _i++) {
        input = inputs[_i];
        arc = new ParallelArc(input[0], input[1]);
        _results.push(assert.isTrue(arc.contains(input[2]), input));
      }
      return _results;
    });
    return test('should work for points outside', function() {
      var arc, input, inputs, _i, _len, _results;
      inputs = [[-49.921875, 64.3359375, 70], [-49.921875, 64.3359375, -70], [-149.0625, 152.578125, 179], [-149.0625, 152.578125, -179], [24.609375, 111.796875, 0], [-155.390625, -93.515625, 124.453125], [-146.953125, 87.890625, 99.53125], [-146.953125, 87.890625, -179.53125], [-107.578125, -146.953125, -120.734375], [149.0625, 98.4375, 100]];
      _results = [];
      for (_i = 0, _len = inputs.length; _i < _len; _i++) {
        input = inputs[_i];
        arc = new ParallelArc(input[0], input[1]);
        _results.push(assert.isFalse(arc.contains(input[2]), input));
      }
      return _results;
    });
  });
  suite('intersects', function() {
    var testAcr;
    testAcr = function(inputs, expected) {
      var arc, arc2, input, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = inputs.length; _i < _len; _i++) {
        input = inputs[_i];
        arc = new ParallelArc(input[0], input[1]);
        arc2 = new ParallelArc(input[2], input[3]);
        _results.push(assert.deepEqual(arc.intersects(arc2), expected, input));
      }
      return _results;
    };
    test('should work for arc inside', function() {
      var inputs;
      inputs = [[20, 50, 30, 35], [-30, 20, -5, 10], [160, -100, 170, -170], [120, 100, -40, 80]];
      return testAcr(inputs, true);
    });
    test('should work for arc partialy inside', function() {
      var inputs;
      inputs = [[45, 60, 50, 80], [160, -20, -170, 20], [120, -45, 10, 150]];
      return testAcr(inputs, true);
    });
    return test('should work for arc not intersecting', function() {
      var inputs;
      inputs = [[38, 60, 70, 120], [150, 100, 120, 130], [-40, 160, 170, -150]];
      return testAcr(inputs, false);
    });
  });
  suite('getLength', function() {
    var testAcr;
    testAcr = function(inputs) {
      var arc, input, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = inputs.length; _i < _len; _i++) {
        input = inputs[_i];
        arc = new ParallelArc(input[0], input[1]);
        _results.push(assert.deepEqual(arc.getLength(), input[2], input));
      }
      return _results;
    };
    test('should work for non crossing date meridian', function() {
      var inputs;
      inputs = [[20, 35, 15], [-20, 34, 54]];
      return testAcr(inputs);
    });
    return test('should work for crossing date meridian', function() {
      var inputs;
      inputs = [[160, -170, 30], [-80, -160, 280]];
      return testAcr(inputs);
    });
  });
  return suite('extend', function() {
    var testAcr;
    testAcr = function(inputs) {
      var arc, extended, input, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = inputs.length; _i < _len; _i++) {
        input = inputs[_i];
        arc = new ParallelArc(input[0], input[1]);
        extended = arc.extend(input[2]);
        assert.deepEqual(extended.getStart(), input[3], input);
        _results.push(assert.deepEqual(extended.getEnd(), input[4], input));
      }
      return _results;
    };
    return test('should work', function() {
      var inputs;
      inputs = [[20, 35, 40, 20, 40], [-20, 34, 20, -20, 34], [-20, 34, -30, -30, 34], [160, -170, 140, 140, -170], [-80, -160, -120, -80, -120]];
      return testAcr(inputs);
    });
  });
});