// Generated by github.com/steida/coffee2closure 0.1.12
goog.require('globeGeometry.encoding');
goog.require('globeGeometry.LatLng');
suite('globeGeometry.encoding', function() {
  var Encoding, LatLng;
  Encoding = globeGeometry.encoding;
  LatLng = globeGeometry.LatLng;
  suite('encodeUnsignedNumber', function() {
    return test('should work with integer', function() {
      var enc;
      enc = Encoding.encodeUnsignedNumber(174);
      return assert.equal(enc, 'mD');
    });
  });
  suite('encodeSignedNumber', function() {
    test('should work with negative float', function() {
      var enc;
      enc = Encoding.encodeSignedNumber(-179.9832104);
      assert.equal(enc, '`~oia@');
      enc = Encoding.encodeSignedNumber(-120.2);
      return assert.equal(enc, '~ps|U');
    });
    return test('should work with float', function() {
      var enc;
      enc = Encoding.encodeSignedNumber(38.5);
      return assert.equal(enc, '_p~iF');
    });
  });
  suite('encodePath', function() {
    return test('should encode path', function() {
      var encodedPath, path;
      path = [new LatLng(38.5, -120.2), new LatLng(40.7, -120.95), new LatLng(43.252, -126.453)];
      encodedPath = Encoding.encodePath(path);
      return assert.equal(encodedPath, '_p~iF~ps|U_ulLnnqC_mqNvxq`@');
    });
  });
  suite('decodeUnsignedNumbers', function() {
    return test('should work with integer', function() {
      var num;
      num = Encoding.decodeUnsignedNumbers('mD')[0];
      return assert.equal(num, 174);
    });
  });
  suite('decodeSignedNumbers', function() {
    test('should work with negative float', function() {
      var num;
      num = Encoding.decodeSignedNumbers('`~oia@');
      assert.equal(num, -179.98321);
      num = Encoding.decodeSignedNumbers('~ps|U');
      return assert.equal(num, -120.2);
    });
    return test('should work with float', function() {
      var num;
      num = Encoding.decodeSignedNumbers('_p~iF');
      return assert.equal(num, 38.5);
    });
  });
  return suite('decodePath', function() {
    return test('should decode path', function() {
      var decodedPath, i, latLng, path, _i, _len, _results;
      path = [new LatLng(38.5, -120.2), new LatLng(40.7, -120.95), new LatLng(43.252, -126.453)];
      decodedPath = Encoding.decodePath('_p~iF~ps|U_ulLnnqC_mqNvxq`@');
      assert.isArray(decodedPath);
      assert.lengthOf(decodedPath, 3);
      _results = [];
      for (i = _i = 0, _len = decodedPath.length; _i < _len; i = ++_i) {
        latLng = decodedPath[i];
        _results.push(assert.isTrue(latLng.equals(path[i])));
      }
      return _results;
    });
  });
});