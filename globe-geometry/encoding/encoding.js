// Generated by github.com/steida/coffee2closure 0.1.12
/**
  @fileoverview Utilities for polyline encoding and decoding
 */
goog.provide('globeGeometry.encoding');
goog.require('globeGeometry.LatLng');
globeGeometry.encoding = function() {}

/**
  @param {Array.<globeGeometry.LatLng>} path
  @return {string}
  @export
  @see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
 */
globeGeometry.encoding.encodePath = function(path) {
  var encoded, latOffset, lngOffset, point, prev, _i, _len;
  encoded = '';
  prev = new globeGeometry.LatLng(0, 0);
  for (_i = 0, _len = path.length; _i < _len; _i++) {
    point = path[_i];
    latOffset = point.getLat() - prev.getLat();
    lngOffset = point.getLng() - prev.getLng();
    encoded += globeGeometry.encoding.encodeSignedNumber(latOffset);
    encoded += globeGeometry.encoding.encodeSignedNumber(lngOffset);
    prev = point;
  }
  return encoded;
};

/**
  @param {string} path
  @return {Array.<globeGeometry.LatLng>}
  @export
  @see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
 */
globeGeometry.encoding.decodePath = function(path) {
  var i, lat, lng, num, nums, points, _i, _len;
  nums = globeGeometry.encoding.decodeSignedNumbers(path);
  lat = lng = 0;
  points = [];
  for (i = _i = 0, _len = nums.length; _i < _len; i = ++_i) {
    num = nums[i];
    if (i % 2 === 0) {
      lat += num;
    }
    if (i % 2 === 1) {
      lng += num;
    }
    if (i > 0 && i % 2 === 1) {
      points.push(new globeGeometry.LatLng(lat, lng));
    }
  }
  return points;
};

/**
  @param {number} value
  @return {string}
  @see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
  @see http://jeromejaglale.com/doc/javascript/google_static_maps_polyline_encoding
 */
globeGeometry.encoding.encodeUnsignedNumber = function(value) {
  var encoded;
  encoded = '';
  while (value >= 0x20) {
    encoded += String.fromCharCode((0x20 | (value & 0x1f)) + 63);
    value >>= 5;
  }
  encoded += String.fromCharCode(value + 63);
  return encoded;
};

/**
  @param {number} value
  @return {string}
  @see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
  @see http://jeromejaglale.com/doc/javascript/google_static_maps_polyline_encoding
 */
globeGeometry.encoding.encodeSignedNumber = function(value) {
  var num;
  value = Math.round(value * 1e5);
  num = value << 1;
  if (value < 0) {
    num = ~num;
  }
  return globeGeometry.encoding.encodeUnsignedNumber(num);
};

/**
  @param {string} encoded
  @return {Array.<number>}
  @see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
  @see http://cheateinstein.com/category-php/decoding-polyline-algorithm-format-javascriptphp/
 */
globeGeometry.encoding.decodeUnsignedNumbers = function(encoded) {
  var b, index, num, nums, shift;
  index = 0;
  nums = [];
  while (index < encoded.length) {
    num = shift = 0;
    while (true) {
      b = encoded.charCodeAt(index++) - 63;
      num |= (b & 0x1f) << shift;
      shift += 5;
      if (!(b >= 0x20)) {
        break;
      }
    }
    nums.push(num);
  }
  return nums;
};

/**
  @param {string} encoded
  @return {Array.<number>}
  @see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
  @see http://cheateinstein.com/category-php/decoding-polyline-algorithm-format-javascriptphp/
 */
globeGeometry.encoding.decodeSignedNumbers = function(encoded) {
  var i, num, nums, _i, _len;
  nums = globeGeometry.encoding.decodeUnsignedNumbers(encoded);
  for (i = _i = 0, _len = nums.length; _i < _len; i = ++_i) {
    num = nums[i];
    num = num & 1 ? ~(num >> 1) : num >> 1;
    nums[i] = num / 1e5;
  }
  return nums;
};